# Authentication & Authorization Architecture

## Authentication Flow (JWT)

We use **Supabase Auth** as the Identity Provider (IdP). The Backend **never** handles passwords.

```mermaid
sequenceDiagram
    participant U as User (Frontend)
    participant S as Supabase Auth
    participant B as FastAPI Backend
    participant D as Database

    Note over U, S: Login Phase
    U->>S: 1. Login with Email/Password
    S-->>U: 2. Returns Access Token (JWT) + Refresh Token

    Note over U, B: Authorized Request
    U->>B: 3. Request API (Header: Bearer <TOKEN>)
    
    rect rgb(240, 240, 240)
        Note right of B: Security Middleware / Dependency
        B->>B: 4. Decode JWT using JWT_SECRET
        B->>B: 5. Verify Signature & Expiry (exp)
        B->>B: 6. Extract user_id (sub)
    end

    B->>D: 7. (Optional) Fetch Role/Status for RBAC
    D-->>B: 8. Return User Role (Brand/Influencer)
    
    B-->>U: 9. JSON Response
```

## Security Pitfalls to Avoid

| Pitfall | Solution |
| :--- | :--- |
| **Trusting the Frontend** | Never rely on the frontend saying "I am an Admin". Always verify the JWT signature on the backend. |
| **Ignoring Expiry (`exp`)** | Always check if the token is expired. `python-jose` handles this, but configuration must be correct. |
| **Weak Secrets** | The `JWT_SECRET` must be a high-entropy string (generated by Supabase). If leaked, attackers can forge admin tokens. |
| **Scope Creep** | Don't accept a standard User token for Admin routes. Enforce explicit `role="admin"` checks. |
| **Leaking Errors** | Don't return "Invalid Signature" or "User not found" explicitly in production to avoid enumeration attacks. Return generic 401. |

## Role Key
- `anon`: Unauthenticated.
- `authenticated`: Logged in, basic access.
- `brand`: Can create campaigns.
- `influencer`: Can view campaigns & receive payments.
- `admin`: Full system access.
